Агоритм не чувствителен к спискам содержащим null значения. Такие значения игнорируются. Смещение индексов не происходит.

Алгоритм работает по следующему принципу:
   - все элементы из передаваемой коллекции кэшируются. В качестве общего кэша выступает HashMap,
   в которой в качестве ключа используется индекс элемента из переданной коллекции, а в качестве
   значения - значение номера элемента.
   Далее элементы разделяются на 4 группы:
   1 - элементы, значения которых равны их индексам, такие элементы игнорируются.
   2 - элементы, значения которых ВЫХОДЯТ ЗА РАМКИ диапазона индексов переданной коллекции и индексы которых
   НЕ присутствуют среди значений других элементов. Для таких элементов сразу в качестве значения
   устанавливается значение их индекса в коллекции.
   3 - элементы, значения которых ВЫХОДЯТ ЗА РАМКИ диапазона индексов переданной коллекции, НО индексы которых
   присутствуют среди значений других элементов. Такие элементы кэшируются в HashMap<Integer, Integer> ValuesOutOfIndexesRange
   4 - элементы, значения которых ВХОДЯТ в диапазон индексов переданной коллекции. Такие элементы кэшируются
   в HashMap<Integer, Integer> valuesInIndexesRange.
 
  Далее происходит присвоение в качестве значений индексов для элементов из 4 группы затем из 3ей.
    
  1a)Алгоритм в 3 группе сначала пытается найти элемент индекс которого не фигурирует ни в одном из значений 3й группы.
  2a)Если такой элемент есть (elementIndex != null), то его значение сохраняется во временную переменную tmp. Само значение меняется на значение
  равное индексу и элемент удаляется из кэша.
  2b)Если такого элемента нет(elementIndex == null), то берётся первый элемент кэша, его значение сохраняется во временную переменную tmp, затем
  его значение заменяется на временное, как в коллекции элементов, так и в кэше.
  3a)Значение tmp становится индексом elementIndex == tmp
  4a)Выполняем проверку из п.2.
  П. с 2 по 4 выполняем до тех пор пока в кэше есть элементы.
 
   Количество вызовов метода IElement.setupNumber для:
   1 группы - 0;
   2 группы - равно количеству элементов входящих в эту группу;
   3 груааа - равно количеству элементов входящих в эту группу;
   4 группа:
       - в лучшем случае - равно количеству элементов входящих в эту группу ([1, 2, 3, 4])
       - в худшем случае - равно количеству элементов входящих в эту группу  1.5 ([1, 0, 3, 2]) (откуда 1.5 см. ниже)
       
*пояснение к п.4
лучший случай: arr[1, 2, 3, 4]
idx - индекс элемента в массиве
val - значкение элемента
rand - временная переменная

idx | val     idx | val    idx | val    idx | val   idx | val
 0  -  1       1  -  2      2  -  3      3  -  4    ---------
 1  -  2       2  -  3      3  -  4     ----------
 2  -  3       3  -  4    ----------    tmp = 4(val)
 3  -  4       --------   tmp = 3(val)
 ---------    tmp = 2(val)
tmp = 1(val) 

4 элемента - 4 замены(каждый раз при замене элемент удаляется из кэша, последний столбик говорит о том что кэш пуст)

худший случай arr[1, 0, 3, 2]
idx | val     idx | val    idx | val    idx | val     idx | val    idx | val    idx | val
 0  -  1       1  -  0      2  -  3      2  -  3      2  - rand     2  - rand   ------------
 1  -  0       2  -  3      3  -  2      3  -  2      3  -  2     -----------   
 2  -  3       3  -  2      0  - rand   ---------     ----------  tmp = 2(val)
 3  -  2       0  - rand    ---------  tmp = 3(val)  tmp = 3(val)
 ---------    ----------    tmp = 0(val) 
tmp = 1(val) tmp = 1(val)

4 элемента - 6 замен т.е на каждую зеркальную пару приходится одна дополнительная замена. Или 6/4 = 1.5